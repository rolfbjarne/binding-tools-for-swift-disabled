// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using SwiftRuntimeLibrary;
using Xamarin.Utils;

namespace Symbolicator {
	public static class Tools {
		public static string[] Exec (string command, params string[] arguments)
		{
			var output = new StringBuilder ();
			var rv = SwiftReflector.IOUtils.ExecAndCollect.RunCommand (command, StringUtils.FormatArguments (arguments), output: output);
			if (rv != 0) {
				var msg = string.Format ("Failed to execute '{0}', exit code {1}.", command, rv);
				Console.WriteLine (msg);
				Console.WriteLine (output);
				throw new Exception (msg);
			}
			return output.ToString ().Split ('\n', '\r');
		}

		// Calls swift-demangle with the -compact argument to demangle a symbol.
		static string Demangle (string str) => Exec ("xcrun", "swift-demangle", "-compact", str).FirstOrDefault ();

		// Gets the output of 'xcrun nm <lib> | xcrun swift-demangle'.
		static IReadOnlyList<string> DemangleLib (string libPath) => Exec ("swift-demangle-lib.sh", libPath );

		static IReadOnlyList<string> grep (string str, string filePath) => Exec ("grep", str, filePath);

		static IReadOnlyList<string> nm (string libPath) => Exec ("xcrun", "nm", libPath);

		// Gets the field constants from a given type.
		static FieldInfo [] GetFields (Type t) => t.GetFields (BindingFlags.NonPublic | BindingFlags.Static).Where (f => f.IsLiteral && !f.IsInitOnly && !f.Name.StartsWith ("Lib", StringComparison.Ordinal)).ToArray ();

		// Gets the 'Lib' field constant from a given type.
		static FieldInfo GetLibField (Type t) => t.GetFields (BindingFlags.NonPublic | BindingFlags.Static).FirstOrDefault (f => f.IsLiteral && !f.IsInitOnly && f.Name.StartsWith ("Lib", StringComparison.Ordinal));

		// Writes StringBuilder to designated file.
		public static void WriteToFile (Type type, StringBuilder code) => WriteToFile (Path.Combine (Directory.GetCurrentDirectory (), $"{type.Name}.cs"), code);
		public static void WriteToFile (string filePath, StringBuilder code) => File.WriteAllText (filePath, code.ToString ());

		class SwiftField {
			public Type ParentType { get; set; }
			public string UsedInClass { get; set; }
			public string FieldName { get; set; }
			public string OldMangledValue { get; set; }
			public string NewMangledValue { get; set; }
			public string DemangledValue { get; set; }
			public SymbolicatorInfoAttribute Info { get; set; }

			public override string ToString () => $"\t\tinternal const string {FieldName} = \"{NewMangledValue}\";";
		}

		static List<SwiftField> GetSwiftFields (Type parentType)
		{
			Console.WriteLine ($"Using: {Exec ("xcode-select", "-p").FirstOrDefault ()}");
			var fields = GetFields (parentType);
			var ret = new List<SwiftField> ();
			foreach (var field in fields) {
				var oldvalue = (string) field.GetRawConstantValue ();
				var demangled = Demangle (oldvalue);
				var usedin = field.Name.Split ('_')[0];
				ret.Add (new SwiftField {
					ParentType = parentType,
					UsedInClass = usedin,
					FieldName = field.Name,
					OldMangledValue = oldvalue,
					DemangledValue = demangled,
					Info = field.GetCustomAttribute<SymbolicatorInfoAttribute> (),
				});
			}
			return ret;
		}

		static StringBuilder GenCode (List<SwiftField> fields)
		{
			var sb = new StringBuilder ();
			var f = fields[0].ParentType;
			var parentName = f.Name;
			var libInfo = GetLibField (f);

			sb.AppendLine ("// Code generated by symbolicator.csx");
			sb.AppendLine ("// You can add constants to this file as needed,");
			sb.AppendLine ("// just make sure you follow this convention for the name:");
			sb.AppendLine ("// '<Type|Interface>_<type>' e.g. 'ISwiftComparable_nuint'.");
			sb.AppendLine ();
			sb.AppendLine ("using System;");
			sb.AppendLine ();
			sb.AppendLine ("namespace SwiftRuntimeLibrary {");
			sb.AppendLine ();
			sb.AppendLine ($"\tinternal static class {parentName} {{");
			sb.AppendLine ();
			if (libInfo != null) {
				sb.AppendLine ($"\t\tinternal const string {libInfo.Name} = \"{libInfo.GetRawConstantValue ()}\";");
				sb.AppendLine ();
			}
			foreach (var group in fields.GroupBy (fi => fi.UsedInClass)) {
				sb.AppendLine ($"\t\t// {group.Key} Constants");
				foreach (var val in group) {
					if (val.Info != null)
						sb.AppendLine (val.Info.ToString ());
					sb.AppendLine (val.ToString ());
				}
				sb.AppendLine ();
			}
			sb.AppendLine ("\t}");
			sb.AppendLine ("}");
			sb.AppendLine ();
			return sb;
		}

		public static StringBuilder UpdateMangledConstants (Type constantsContainer, string libPath)
		{
			var fields = GetSwiftFields (constantsContainer);
			var demangledInfo = DemangleLib (libPath);
			var nmLibInfo = nm (libPath);

			Parallel.ForEach (fields, field => {
				var info = field.Info;
				if (info != null && info.Skip) {
					field.NewMangledValue = field.OldMangledValue;
				} else {
					var demangled = info?.DemangledString ?? field.DemangledValue;
					var address = demangledInfo.FirstOrDefault (s => s.EndsWith (demangled, StringComparison.Ordinal))?.Split (' ') [0];
					field.NewMangledValue = nmLibInfo.FirstOrDefault (s => s.StartsWith (address, StringComparison.Ordinal))?.Split (' ') [2];
					field.NewMangledValue = field.NewMangledValue [0] == '_' ? field.NewMangledValue.Substring (1) : field.NewMangledValue;
				}
			});

			return GenCode (fields);
		}
	}
}
